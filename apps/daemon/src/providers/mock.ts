import { ProviderAdapter, ProviderTask, ProviderOutputEvent } from "./types.js";

function sleep(ms: number): Promise<void> {
  return new Promise((r) => setTimeout(r, ms));
}

export class MockProvider implements ProviderAdapter {
  id = "mock";
  displayName = "Mock";
  kind = "mock";
  capabilities = {
    streaming: true,
    structuredOutput: true,
    resumableSessions: false,
  };

  async healthCheck() {
    return { ok: true, message: "mock provider ready" };
  }

  async *runTask(task: ProviderTask, _signal: AbortSignal): AsyncIterable<ProviderOutputEvent> {
    yield { type: "progress", message: `[mock] starting role=${task.role}` };
    await sleep(50);

    if (task.role === "investigator") {
      const brief = {
        repoBrief: {
          guess: "Mock provider does not inspect the repo.",
          suggestedVerification: ["npm test", "npm run lint", "pytest", "go test ./..."],
        },
      };
      yield { type: "json", name: "repo-brief.json", json: brief };
      yield { type: "final", output: brief, summary: "Investigation complete (mock)." };
      return;
    }

    if (task.role === "planner") {
      const plan = {
        summary: "Single-step plan generated by mock provider (v0).",
        steps: [
          {
            id: "impl-1",
            title: "Implement requested changes",
            instructions: task.prompt,
            agentHint: "any",
            deps: [],
          },
        ],
      };
      yield { type: "json", name: "plan.json", json: plan };
      yield { type: "final", output: plan, summary: "Planning complete (mock)." };
      return;
    }

    if (task.role === "reviewer") {
      const review = {
        ok: true,
        issues: [],
        notes: "Mock reviewer always passes.",
      };
      yield { type: "json", name: "review.json", json: review };
      yield { type: "final", output: review, summary: "Review complete (mock)." };
      return;
    }

    // implementer (or other)
    // implementer (or other)
    yield { type: "progress", message: "[mock] generating patch (placeholder)" };

    // Simulate streaming text
    const streamContent = "This is a simulated streaming response from the Mock Provider.\nIt should appear character by character in the UI.\n\n```typescript\nconsole.log('Hello from Mock!');\n```\n";
    for (const char of streamContent) {
      yield { type: "message.delta", delta: char };
      await sleep(20); // 20ms delay per char (~50 chars/sec)
    }

    await sleep(50);
    const patch = [
      "diff --git a/README.md b/README.md",
      "index 0000000..1111111 100644",
      "--- a/README.md",
      "+++ b/README.md",
      "@@",
      "+(mock) vuhlp code would apply real changes here.",
      "",
    ].join("\n");
    yield { type: "diff", name: "mock.patch", patch };
    yield { type: "final", output: { patch }, summary: "Implementation complete (mock placeholder patch)." };
  }
}
